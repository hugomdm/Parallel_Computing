#print(infection_matrix[i,j])
#check number of neighbors are infected
n_infected <- find_infected_neighbors(infection_matrix, i, j)
#if the probability is bigger than the probability remaining uninfected (1 âˆ’ alpha)^n_infected
if (runif(1) > (1 - alpha)^n_infected) {
#it changes status for on fire
return(1)
}
#else if an individual is on fire
} else if (infection_matrix[i,j] == 1) {
#the forest will continue burning
#if probability if less than beta an individual is removed
if (runif(1) < beta) {
#it will be burn out
return(0)
}}
return(infection_matrix[i,j])
}
forest.fire <- function( infection_matrix, alpha, beta, pausing = FALSE) {
require(parallel)
#' Function to simulate a forest fire epidemic model
#' For infection_matrix[i, j] = 2, person is unburnt; 1 for on fire; 0 for burnt out.
#' An on fire individual can only infect unburnt individuals if they are neighbors.
#' @param infection_matrix : main infection_matrix that maps an individual and
#' its current state state (unburnt, on fire or burnt out)
#' @param alpha: probability of an infected individual of infecting each of its susceptible neighbors
#' @param beta: probability of an individual that was on fire and had a chance of
#' affecting people of getting unburnt
#' @param pausing
#'
#' @return infection_matrix: returns the updated infection_matrix after the simulation
#'
#----------- PLOTS ---------------
#defines the white space of the plot with width and height of the main matrimain_matrix
#plot(c(1,nrow(infection_matrix)), c(1,ncol(infection_matrix)), type = "n", Xlab = "", ylab = "")
#plots the points that represents the individual in space
#forest.fire.plot(infection_matrix)
#----------- MAIN --------------
#Create cluster
cl <- parallel::makeCluster(parallel::detectCores())
#Register it for the foreach loop
doParallel::registerDoParallel(cl)
#Export the dataset (could be done directly in the foreach, but this is more explicit)
parallel::clusterExport(cl, varlist = c("infection_matrix", "utils", "find_infected_neighbors"))
burning <- TRUE
while (burning) {
#if the forest is still "burning" continue: if the fire is still spreading its still affecting individuals
# check if pausing between updates
if (pausing) {
input <- readline("hit any key to continue")
}
#iterate though the infection_matrix
infection_matrix_copy <-  foreach(i= 1:nrow(infection_matrix)) %:%
foreach(j = 1:ncol(infection_matrix )) %dopar%{
utils(infection_matrix, i, j, alpha, beta)
}
infection_matrix <- do.call(cbind, infection_matrix_copy)
infection_matrix <- t(infection_matrix)
print(infection_matrix)
burning <- any(infection_matrix == 1)
print(burning)
# plot the updated infection panel
#forest.fire.plot(infection_matrix)
}
parallel::stopCluster(cl)
return(infection_matrix)
}
#clusterExport(cl, varlist = c('infection_matrix', 'alpha','beta'))
# spark
set.seed(3)
#initialize a infection_matrix of 21x21 with only 2 values (susceptible people)
infection_matrix <- matrix(2, 21, 21)
#in the central position of the infection_matrix set a 1 value
infection_matrix[11, 11] <- 1
#Recursive function
infection_matrix <- forest.fire(infection_matrix, .2, .4, FALSE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/forest_fire_for_each.R", encoding = 'UTF-8', echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/forest_fire_for_each.R", encoding = 'UTF-8', echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/forest_fire_for_each.R", encoding = 'UTF-8', echo=TRUE)
forest.fire <- function( infection_matrix, alpha, beta, pausing = FALSE) {
require(parallel)
#' Function to simulate a forest fire epidemic model
#' For infection_matrix[i, j] = 2, person is unburnt; 1 for on fire; 0 for burnt out.
#' An on fire individual can only infect unburnt individuals if they are neighbors.
#' @param infection_matrix : main infection_matrix that maps an individual and
#' its current state state (unburnt, on fire or burnt out)
#' @param alpha: probability of an infected individual of infecting each of its susceptible neighbors
#' @param beta: probability of an individual that was on fire and had a chance of
#' affecting people of getting unburnt
#' @param pausing
#'
#' @return infection_matrix: returns the updated infection_matrix after the simulation
#'
#----------- PLOTS ---------------
#defines the white space of the plot with width and height of the main matrimain_matrix
#plot(c(1,nrow(infection_matrix)), c(1,ncol(infection_matrix)), type = "n", Xlab = "", ylab = "")
#plots the points that represents the individual in space
#forest.fire.plot(infection_matrix)
#----------- MAIN --------------
#Create cluster
cl <- parallel::makeCluster(parallel::detectCores())
#Register it for the foreach loop
doParallel::registerDoParallel(cl)
#Export the dataset (could be done directly in the foreach, but this is more explicit)
parallel::clusterExport(cl, varlist = c("infection_matrix", "utils", "find_infected_neighbors"))
burning <- TRUE
while (burning) {
#if the forest is still "burning" continue: if the fire is still spreading its still affecting individuals
# check if pausing between updates
if (pausing) {
input <- readline("hit any key to continue")
}
#iterate though the infection_matrix
infection_matrix_copy <-  foreach(i= 1:nrow(infection_matrix)) %:%
foreach(j = 1:ncol(infection_matrix )) %dopar%{
utils(infection_matrix, i, j, alpha, beta)
}
print(infection_matrix_copy)
infection_matrix <- do.call(cbind, infection_matrix_copy)
#print(infection_matrix)
infection_matrix <- t(infection_matrix)
burning <- any(infection_matrix == 1)
# plot the updated infection panel
#forest.fire.plot(infection_matrix)
}
parallel::stopCluster(cl)
return(infection_matrix)
}
#clusterExport(cl, varlist = c('infection_matrix', 'alpha','beta'))
# spark
set.seed(3)
#initialize a infection_matrix of 21x21 with only 2 values (susceptible people)
infection_matrix <- matrix(2, 21, 21)
#in the central position of the infection_matrix set a 1 value
infection_matrix[11, 11] <- 1
#Recursive function
infection_matrix <- forest.fire(infection_matrix, .2, .4, FALSE)
forest.fire <- function( infection_matrix, alpha, beta, pausing = FALSE) {
require(parallel)
#' Function to simulate a forest fire epidemic model
#' For infection_matrix[i, j] = 2, person is unburnt; 1 for on fire; 0 for burnt out.
#' An on fire individual can only infect unburnt individuals if they are neighbors.
#' @param infection_matrix : main infection_matrix that maps an individual and
#' its current state state (unburnt, on fire or burnt out)
#' @param alpha: probability of an infected individual of infecting each of its susceptible neighbors
#' @param beta: probability of an individual that was on fire and had a chance of
#' affecting people of getting unburnt
#' @param pausing
#'
#' @return infection_matrix: returns the updated infection_matrix after the simulation
#'
#----------- PLOTS ---------------
#defines the white space of the plot with width and height of the main matrimain_matrix
#plot(c(1,nrow(infection_matrix)), c(1,ncol(infection_matrix)), type = "n", Xlab = "", ylab = "")
#plots the points that represents the individual in space
#forest.fire.plot(infection_matrix)
#----------- MAIN --------------
#Create cluster
cl <- parallel::makeCluster(parallel::detectCores())
#Register it for the foreach loop
doParallel::registerDoParallel(cl)
#Export the dataset (could be done directly in the foreach, but this is more explicit)
parallel::clusterExport(cl, varlist = c("infection_matrix", "utils", "find_infected_neighbors"))
burning <- TRUE
while (burning) {
#if the forest is still "burning" continue: if the fire is still spreading its still affecting individuals
# check if pausing between updates
if (pausing) {
input <- readline("hit any key to continue")
}
#iterate though the infection_matrix
infection_matrix_copy <-  foreach(i= 1:nrow(infection_matrix)) %:%
foreach(j = 1:ncol(infection_matrix )) %dopar%{
utils(infection_matrix, i, j, alpha, beta)
}
print(infection_matrix_copy)
#infection_matrix <- do.call(cbind, infection_matrix_copy)
print(Reduce(cbind,infection_matrix_copy))
infection_matrix <- t(infection_matrix)
burning <- any(infection_matrix == 1)
# plot the updated infection panel
#forest.fire.plot(infection_matrix)
}
parallel::stopCluster(cl)
return(infection_matrix)
}
#clusterExport(cl, varlist = c('infection_matrix', 'alpha','beta'))
# spark
set.seed(3)
#initialize a infection_matrix of 21x21 with only 2 values (susceptible people)
infection_matrix <- matrix(2, 21, 21)
#in the central position of the infection_matrix set a 1 value
infection_matrix[11, 11] <- 1
#Recursive function
infection_matrix <- forest.fire(infection_matrix, .2, .4, FALSE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/forest_fire_for_each.R", encoding = 'UTF-8', echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/forest_fire_for_each.R", encoding = 'UTF-8', echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/forest_fire_for_each.R", encoding = 'UTF-8', echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/forest_fire_for_each.R", encoding = 'UTF-8', echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/forest_fire_for_each.R", encoding = 'UTF-8', echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/forest_fire_paralellized.R", encoding = 'UTF-8', echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/forest_fire_for_each.R", encoding = 'UTF-8', echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/forest_fire_for_each.R", encoding = 'UTF-8', echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/forest_fire_for_each.R", encoding = 'UTF-8', echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/forest_fire_for_each.R", encoding = 'UTF-8', echo=TRUE)
forest.fire <- function( infection_matrix, alpha, beta, pausing = FALSE) {
require(parallel)
#' Function to simulate a forest fire epidemic model
#' For infection_matrix[i, j] = 2, person is unburnt; 1 for on fire; 0 for burnt out.
#' An on fire individual can only infect unburnt individuals if they are neighbors.
#' @param infection_matrix : main infection_matrix that maps an individual and
#' its current state state (unburnt, on fire or burnt out)
#' @param alpha: probability of an infected individual of infecting each of its susceptible neighbors
#' @param beta: probability of an individual that was on fire and had a chance of
#' affecting people of getting unburnt
#' @param pausing
#'
#' @return infection_matrix: returns the updated infection_matrix after the simulation
#'
#----------- PLOTS ---------------
#defines the white space of the plot with width and height of the main matrimain_matrix
#plot(c(1,nrow(infection_matrix)), c(1,ncol(infection_matrix)), type = "n", Xlab = "", ylab = "")
#plots the points that represents the individual in space
#forest.fire.plot(infection_matrix)
#----------- MAIN --------------
#Create cluster
cl <- parallel::makeCluster(parallel::detectCores())
#Register it for the foreach loop
doParallel::registerDoParallel(cl)
#Export the dataset (could be done directly in the foreach, but this is more explicit)
parallel::clusterExport(cl, varlist = c("infection_matrix", "utils", "find_infected_neighbors"))
burning <- TRUE
while (burning) {
#if the forest is still "burning" continue: if the fire is still spreading its still affecting individuals
# check if pausing between updates
if (pausing) {
input <- readline("hit any key to continue")
}
#iterate though the infection_matrix
infection_matrix_copy <-  foreach(i= 1:nrow(infection_matrix)) %:%
foreach(j = 1:ncol(infection_matrix )) %dopar%{
utils(infection_matrix, i, j, alpha, beta)
}
#infection_matrix <- do.call(cbind, infection_matrix)
infection_matrix <- matrix(unlist(infection_matrix_copy), ncol = ncol(infection_matrix), byrow = TRUE)
print(infection_matrix)
infection_matrix <- t(infection_matrix)
burning <- any(infection_matrix == 1)
# plot the updated infection panel
#forest.fire.plot(infection_matrix)
}
parallel::stopCluster(cl)
return(infection_matrix)
}
#clusterExport(cl, varlist = c('infection_matrix', 'alpha','beta'))
# spark
set.seed(3)
#initialize a infection_matrix of 21x21 with only 2 values (susceptible people)
infection_matrix <- matrix(2, 21, 21)
#in the central position of the infection_matrix set a 1 value
infection_matrix[11, 11] <- 1
#Recursive function
infection_matrix <- forest.fire(infection_matrix, .2, .4, FALSE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/forest_fire_for_each.R", encoding = 'UTF-8', echo=TRUE)
gc()
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/comparing_algos.R", echo=TRUE)
setwd("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code")
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/comparing_algos.R", echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/comparing_algos.R", echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/comparing_algos.R", echo=TRUE)
gc()
set.seed(3)
# # #initialize a infection_matrix of 21x21 with only 2 values (susceptible people)
infection_matrix <- matrix(2, 21, 21)
# # #in the central position of the infection_matrix set a 1 value
infection_matrix[11, 11] <- 1
infection_matrix <- t(infection_matrix)
n <- nrow(infection_matrix)
mat.pad = rbind(NA, cbind(NA, infection_matrix, NA), NA)
ind = 2:(n + 1) # row/column indices of the "middle"
neigh = rbind(N  = as.vector(mat.pad[ind - 1, ind    ]),
NE = as.vector(mat.pad[ind - 1, ind + 1]),
E  = as.vector(mat.pad[ind    , ind + 1]),
SE = as.vector(mat.pad[ind + 1, ind + 1]),
S  = as.vector(mat.pad[ind + 1, ind    ]),
SW = as.vector(mat.pad[ind + 1, ind - 1]),
W  = as.vector(mat.pad[ind    , ind - 1]),
NW = as.vector(mat.pad[ind - 1, ind - 1]),
R = as.vector(mat.pad[ind , ind ]))
lapply(neigh , function(x) {
length(which(x == 1)) })
sapply(neigh , function(x) {
length(which(x == 1)) })
n <- t(neigh)
lapply(n , function(x) {
length(which(x == 1)) })
sapply(n , function(x) {
length(which(x == 1)) })
apply(n , 2, function(x) {
length(which(x == 1)) })
apply(n , 1, function(x) {
length(which(x == 1)) })
rowSums(n == 30)
rowSums(n == 1)
rowSums(neigh == 1)
lapply(n , function(x) {
length(which(x == 1)) })
a <- split(n, rep(1:21))
a
lapply(a , function(x) {
length(which(x == 1)) })
infection_matrix <- t(infection_matrix)
n <- nrow(infection_matrix)
mat.pad = rbind(NA, cbind(NA, infection_matrix, NA), NA)
ind = 2:(n + 1) # row/column indices of the "middle"
neigh = rbind(N  = as.vector(mat.pad[ind - 1, ind    ]),
NE = as.vector(mat.pad[ind - 1, ind + 1]),
E  = as.vector(mat.pad[ind    , ind + 1]),
SE = as.vector(mat.pad[ind + 1, ind + 1]),
S  = as.vector(mat.pad[ind + 1, ind    ]),
SW = as.vector(mat.pad[ind + 1, ind - 1]),
W  = as.vector(mat.pad[ind    , ind - 1]),
NW = as.vector(mat.pad[ind - 1, ind - 1]),
R = as.vector(mat.pad[ind , ind ]))
neigh
n <- t(neigh)
n
a <- split(n, rep(1:421))
a <- split(n, rep(1:420))
a <- split(n, rep(1))
a
n <- t(neigh)
a <- split(n, rep(1:441))
a
lapply(a , function(x) {
length(which(x == 1)) })
b <- lapply(a , function(x) {
length(which(x == 1)) })
Reduce(c,b)
number_infected_neigh <- apply(neigh, 2, function(x) {
length(which(x == 1))})
number_infected_neigh
n*n
n <- nrow(infection_matrix)
n*n
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/comparing_algos.R", echo=TRUE)
infection_matrix <- t(infection_matrix)
n <- nrow(infection_matrix)
mat.pad = rbind(NA, cbind(NA, infection_matrix, NA), NA)
ind = 2:(n + 1) # row/column indices of the "middle"
neigh = rbind(N  = as.vector(mat.pad[ind - 1, ind    ]),
NE = as.vector(mat.pad[ind - 1, ind + 1]),
E  = as.vector(mat.pad[ind    , ind + 1]),
SE = as.vector(mat.pad[ind + 1, ind + 1]),
S  = as.vector(mat.pad[ind + 1, ind    ]),
SW = as.vector(mat.pad[ind + 1, ind - 1]),
W  = as.vector(mat.pad[ind    , ind - 1]),
NW = as.vector(mat.pad[ind - 1, ind - 1]),
R = as.vector(mat.pad[ind , ind ]))
data <- split(t(neigh), rep(1:(n*n)))
neigh_apply <- foreach(i= data) %dopar% {
ength(which(x == 1)) }
neigh_apply <- foreach(i= data) %dopar% {
length(which(x == 1)) }
neigh_apply <- foreach(i= data) %dopar% {
length(which(i == 1)) }
neigh_apply
Reduce(c, neigh_apply)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/comparing_algos.R", echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/comparing_algos.R", echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/forest_file_neighboord_optimized_lapply.R", echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/forest_file_neighboord_optimized_lapply.R", echo=TRUE)
gc()
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/comparing_algos.R", echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/forest_file_neighboord_optimized_lapply.R", echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/forest_file_neighboord_optimized_lapply.R", echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/forest_file_neighboord_optimized_lapply.R", echo=TRUE)
infection_matrix <- t(infection_matrix)
n <- nrow(infection_matrix)
mat.pad = rbind(NA, cbind(NA, infection_matrix, NA), NA)
ind = 2:(n + 1) # row/column indices of the "middle"
neigh = rbind(N  = as.vector(mat.pad[ind - 1, ind    ]),
NE = as.vector(mat.pad[ind - 1, ind + 1]),
E  = as.vector(mat.pad[ind    , ind + 1]),
SE = as.vector(mat.pad[ind + 1, ind + 1]),
S  = as.vector(mat.pad[ind + 1, ind    ]),
SW = as.vector(mat.pad[ind + 1, ind - 1]),
W  = as.vector(mat.pad[ind    , ind - 1]),
NW = as.vector(mat.pad[ind - 1, ind - 1]),
R = as.vector(mat.pad[ind , ind ]))
data <- split(t(neigh), rep(1:(n*n)))
neigh_apply <- parLapply(data, function(x){
length(which(x == 1))
})
gc()
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/forest_file_neighboord_optimized_lapply.R", echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/forest_file_neighboord_optimized_lapply.R", echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/forest_file_neighboord_optimized_lapply.R", echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/comparing_algos.R", echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/forest_fire_neighboord_apply.R", echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/forest_fire_neighboord_apply.R", echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/comparing_algos.R", echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/comparing_algos.R", echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/comparing_algos.R", echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/comparing_algos.R", echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/comparing_algos.R", echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/comparing_algos.R", echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/forest_fire_neigh_apply.R", echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/comparing_algos.R", echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/comparing_algos.R", echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/comparing_algos.R", echo=TRUE)
print("i:" + str(i) + " j: "+ str(j))
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/forest_file_commented.R", echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/forest_fire_neigh_apply.R", echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/forest_fire_neigh_apply.R", echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/forest_fire_neigh_apply.R", echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/forest_file_commented.R", echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/forest_file_commented.R", echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/forest_fire_neigh_apply.R", echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/forest_fire_neigh_apply.R", echo=TRUE)
infection_vector =c(infection_matrix)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/forest_fire_neigh_apply.R", echo=TRUE)
set.seed(3)
gc()
set.seed(3)
# # #initialize a infection_matrix of 21x21 with only 2 values (susceptible people)
infection_matrix <- matrix(2, 21, 21)
# # #in the central position of the infection_matrix set a 1 value
infection_matrix[11, 11] <- 1
infection_vector =c(t(infection_matrix))
infection_vector
infection_vector[221]
find_infected_neigh <- function(infection_matrix) {
n <- nrow(infection_matrix)
mat.pad = rbind(NA, cbind(NA, infection_matrix, NA), NA)
ind = 2:(n + 1) # row/column indices of the "middle"
neigh = rbind(N  = as.vector(mat.pad[ind - 1, ind    ]),
NE = as.vector(mat.pad[ind - 1, ind + 1]),
E  = as.vector(mat.pad[ind    , ind + 1]),
SE = as.vector(mat.pad[ind + 1, ind + 1]),
S  = as.vector(mat.pad[ind + 1, ind    ]),
SW = as.vector(mat.pad[ind + 1, ind - 1]),
W  = as.vector(mat.pad[ind    , ind - 1]),
NW = as.vector(mat.pad[ind - 1, ind - 1]))
number_infected_neigh <- apply(neigh, 2, function(x) {
length(which(x == 1))})
return(number_infected_neigh)
}
number_infected_neigh <- find_infected_neigh(infection_matrix)
number_infected_neigh
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/forest_fire_neigh_apply.R", echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/forest_fire_neigh_apply.R", echo=TRUE)
#forest_fire_commented(infection_matrix, .2, .4, FALSE)
microbenchmark(#forest.fire.original(infection_matrix, .2, .4, FALSE),
forest_fire_commented(infection_matrix, .2, .4, FALSE),
forest_fire_opt_neigh_commented(infection_matrix, .2, .4, FALSE),
forest_fire_rcpp(infection_matrix, .2, .4, FALSE),
forest_fire_neighbors_lapply(infection_matrix, .2, .4, FALSE),
forest_fire_opt_neigh_apply(infection_matrix, .2, .4, FALSE),
times=10)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/comparing_algos.R", echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/comparing_algos.R", echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/forest_fire_neigh_apply.R", echo=TRUE)
profvis::profvis({result <- forest_fire_opt_neigh_apply(infection_matrix, .2, .4, FALSE)})
View(infection_matrix)
colSums(infection_matrix==1)
infection_matrix <- t(infection_matrix)
n <- nrow(infection_matrix)
mat.pad = rbind(NA, cbind(NA, infection_matrix, NA), NA)
ind = 2:(n + 1) # row/column indices of the "middle"
neigh = rbind(N  = as.vector(mat.pad[ind - 1, ind    ]),
NE = as.vector(mat.pad[ind - 1, ind + 1]),
E  = as.vector(mat.pad[ind    , ind + 1]),
SE = as.vector(mat.pad[ind + 1, ind + 1]),
S  = as.vector(mat.pad[ind + 1, ind    ]),
SW = as.vector(mat.pad[ind + 1, ind - 1]),
W  = as.vector(mat.pad[ind    , ind - 1]),
NW = as.vector(mat.pad[ind - 1, ind - 1]),
R = as.vector(mat.pad[ind , ind ]))
neigh
colSums(neigh==1)
View(neigh)
a <- colSums(neigh==1)
number_infected_neigh <- apply(neigh, 2, function(x) {
length(which(x == 1))})
number_infected_neigh
a
neigh
t(neigh)
colSums(neigh==1)
number_infected_neigh
colSums(neigh==1, na.rm=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/forest_fire_neigh_apply.R", echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/forest_fire_neigh_apply.R", echo=TRUE)
profvis::profvis({result <- forest_fire_opt_neigh_apply(infection_matrix, .2, .4, FALSE)})
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/comparing_algos.R", echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/forest_fire_neigh_apply.R", echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/comparing_algos.R", echo=TRUE)
profvis::profvis({result <- forest_fire_opt_neigh_apply(infection_matrix, .2, .4, FALSE)})
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/comparing_algos.R", echo=TRUE)
profvis::profvis({result <- forest_fire_opt_neigh_commented(infection_matrix, .2, .4, FALSE)})
number_infected_neigh <- apply(neigh, 2, function(x) {
sum(x == 1)})
number_infected_neigh
number_infected_neigh <- apply(neigh, 2, function(x) {
sum(x == 1, na.rm=T)})
number_infected_neigh
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/comparing_algos.R", echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/comparing_algos.R", echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/comparing_algos.R", echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/comparing_algos.R", echo=TRUE)
source("~/Master - DataMining/Projets/Parallel_Computing/amelioration_code/comparing_algos.R", echo=TRUE)
